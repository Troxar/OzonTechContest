S. Интернет-магазин: анализ тегов товаров (SQL, 25 баллов)
ограничение по времени на тест: 15 секунд
ограничение по памяти на тест: 1024 мегабайта
ввод: стандартный ввод
вывод: стандартный вывод

Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. Запрос может содержать произвольное количество подзапросов, других конструкций, быть сколь угодно навороченным, но это должен быть один запрос (в нём не должна встречаться точка с запятой для разделения разных запросов).
При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сервис http://sqlfiddle.com/ как инструмент для запуска запросов.
В этой задаче вам предстоит написать запрос к базе данных простейшего интернет-магазина.
Напишите запрос к базе данных, который возвращает все теги товаров вместе с некоторой дополнительной информацией:
•	названием клиента, который приобрёл товаров с таким тегом на наибольшую сумму (выберите клиента с минимальным id в случае неоднозначности), соответствующую колонку в выводе следует назвать client_name,
•	соответствующая этому клиенту наибольшая сумма, колонку в выводе следует назвать total.
Строки в выводе сортируйте в первую очередь по невозрастанию total, затем по возрастанию id тега продукта.
Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.
Схема базы данных содержит шесть таблиц:
•	clients — клиенты (описываются двумя полями: id и name),
•	products — товары (описываются двумя полями: id и name),
•	product_tags — теги товаров (описываются двумя полями: id и name),
•	product_prices — цены за единицу товара, цена действует с момента своего создания до следующей цены на этот товар (описываются четырьмя полями: id, product_id, price и created_at),
•	products_product_tags — задаёт отношение «многие ко многим» между товарами и тегами товаров (описывается двумя полями: product_id и product_tag_id),
•	orders — заказы, каждый заказ характеризуется клиентом, товаром, количеством единиц товара и датой-временем (описываются 55 полями: id, client_id, product_id, quantity и created_at).
Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма ниже иллюстрирует схему базы данных.

<task-S-image1.png>
 
Все пары product_id-product_tag_id в products_product_tags — различны. Все пары product_id-created_at в product_prices — различны. Поля name в соответствующих трёх таблицах — уникальны.
Цена за единицу товара для каждого заказа выбирается на основании таблицы product_prices — выбирается последняя (наиболее поздняя) цена, установленная не позднее даты-времени заказа. Если такой нет, то заказ игнорируется.
В выводе следует игнорировать такие теги товаров, по которым не было неигнорированных заказов.

Входные данные:
Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.

Выходные данные:
Ваш SQL-запрос должен вывести всех пользователей вместе с дополнительными колонками, как написано выше. В точности следуйте требованиям к именованию дополнительных колонок и порядку сортировки.
Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод на примерах.

Примеры:

#1
Входные данные:
create table clients (
  id bigint primary key,
  name varchar not null unique
);

create table products (
  id bigint primary key,
  name varchar not null unique
);

create table product_prices (
  id bigint primary key,
  product_id bigint,
  price bigint,
  created_at timestamp not null,
  constraint fk_product_prices_product_id foreign key (product_id) references products (id)
);

create unique index on product_prices (product_id, created_at);

create table product_tags (
  id bigint primary key,
  name varchar not null unique
);

create table products_product_tags (
  product_id bigint,
  product_tag_id bigint,
  constraint fk_products_product_tags_product_id foreign key (product_id) references products (id),
  constraint fk_products_product_tags_product_tag_id foreign key (product_tag_id) references product_tags (id)
);

create unique index on products_product_tags (product_id, product_tag_id);

create table orders (
  id bigint primary key,
  client_id bigint,
  product_id bigint,
  quantity int,
  created_at timestamp not null,
  constraint fk_orders_client_id foreign key (client_id) references clients (id),
  constraint fk_orders_product_id foreign key (product_id) references products (id)
);

insert into clients
values (1, 'Booble'),
       (2, 'Macrohard'),
       (3, 'Pineapple'),
       (4, 'Fakebook');

insert into products
values (1, 'Paper'),
       (2, 'Laptop'),
       (3, 'Shovel');

insert into product_prices
values (1, 1, 5, '2023-04-01 12:30:45'),
       (2, 3, 20, '2023-04-01 17:45:00'), 
       (3, 2, 900, '2023-04-02 00:00:00'), 
       (4, 1, 6, '2023-04-02 12:30:45'), 
       (5, 3, 15, '2023-04-02 09:00:00'),
       (6, 2, 1250, '2023-04-03 00:00:00'), 
       (7, 3, 25, '2023-04-01 19:45:00'), 
       (8, 2, 1000, '2023-04-01 00:00:00');

insert into product_tags
values (10, 'tool'),
       (20, 'office'),
       (30, 'outdoor'),
       (40, 'electronic'),
       (50, 'none');

insert into products_product_tags
values (1, 20),
       (2, 10),
       (2, 40),
       (3, 10),
       (3, 30);

insert into orders
values (1, 3, 2, 10, '2023-04-01 09:10:00'),
       (2, 3, 2, 10, '2023-04-01 23:59:59'),
       (3, 3, 2, 10, '2023-04-02 00:00:00'),
       (4, 3, 1, 1, '2023-03-02 00:00:00'),
       (5, 3, 1, 1, '2023-04-02 00:00:00'),
       (6, 1, 3, 2, '2023-04-01 17:45:00'),
       (7, 1, 3, 33, '2023-04-01 19:45:01'),
       (8, 4, 1, 6, '2024-04-01 19:45:01'),
       (9, 4, 2, 7, '2024-04-01 19:45:01'),
       (10, 4, 3, 10, '2024-04-01 19:45:01');
	   
Выходные данные:
 id | name       | client_name | total 
----+------------+-------------+-------
 10 | tool       | Pineapple   | 29000 
 40 | electronic | Pineapple   | 29000 
 30 | outdoor    | Booble      |   865 
 20 | office     | Fakebook    |    36 